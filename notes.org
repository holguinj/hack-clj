* Compiling nonterminals
** Intro
Ok, tricky situation. Apparently.
Let's look at some common nonterminals:
  - class
  - function

Each one is introduced by a keyword. Here's a sample transformation:

  <keyword> class </keyword>

  ->BECOMES->

  <class>
    <keyword> class </keyword>

** Nonterminal stacks
Obviously that's not all. Classes are demarcated by {}. But they can contain
inner blocks (probably functions) that are also demarcated by {}, so we need
to track where we are in a stack (blocks are FILO).

When we emit <class>, the next "{" bracket we output will be the beginning of
the class block. We can conj "class" onto the `bracket` stack:

  <class> -> {:bracket '(:class)}

Next, we'll probably come across a function. So we'll do something like this:

  <keyword> function </keyword>

  ->BECOMES->

  <subroutineDec>
    <keyword> function </keyword>

and conj :subroutineDec to our bracket stack:

  <subroutineDec> -> {:bracket '(:subroutineDec :class)}

A few lines or so later, we reach a "}":

  <symbol> } </symbol>

Time to pop the stack and emit a closing tag for whatever pops out:

  {:bracket '(:subroutineDec :class)} -> :subroutineDec
  emit </subroutineDec>, state := {:bracket '(:class)}

The next time we come across "}", it must mean we're closing out the class:

  {:bracket '(:class)} -> :class
  emit </class>, state := {:bracket '()}

** On the idea of "recursive descent"
I had been sort of freaking myself out about this because I worried about
how to represent the input code in such a way that I could split it up and
compile blocks within blocks within blocks without losing my place in the
overall scheme.

But there's really no need to worry. I can take each token as it comes and
compile it as long as I keep track of the *reader's position* within the stack.
** Track open punctuation or not? (yes, do)
Interesting question: should we bother to even notice "{"? Right now the answer
seems to be "no." There's nothing to even do with it now other than emit
the XML straight out of the tokenizer. But that's just because classes are
sort of funny like that.

Functions are much more particular. They have a <parameterList> intervening
between the "function" keyword and the <subroutineBody>. You can't emit the
<subroutineBody> tag until just before the "{".

*** IT'S SO COMPLICATED
Ok, so symbol compilation is going to have a bit more logic than I had
anticipated. The AST format prescribed by these assholes is needlessly
inconsistent (miss you, LISP).

Here's an example: when compiling <symbol> { </symbol>, you've got to check
the top of the "brace" stack. If it's :class, then just IGNORE IT and emit
the token. If the top of the stack is :constructor or :function, then you
should emit:
  <subroutineBody>
    <symbol> { </symbol>
    <statements>

When you get to "<symbol> } </symbol>", check the top of the stack again.
If it's still :constructor (maybe :function, not sure), then emit this:
      </statements>
      <symbol> } </symbol>
    </subroutineBody>
  </subroutineDec>

"</subroutineDec>" might seem to be coming out of nowhere. The opening tag
is emitted way earlier, when compiling "<keyword> function </keyword>".
See the inconsistency?

** Linting
It would be interesting to write a basic linter to check for any glaring
syntax errors early on. Well, it would be interesting if I could figure out a
way to express the syntactic restrictions declaratively, maybe something like:

  {[:keyword :class] [[:identifier] [:symbol "{"]]}
  "a class keyword must be followed by an identifier, then a '{' symbol"

Just spitballing.

** Symbols and what they do (notes for compile-symbol)
*** :open-brace
**** :class
     Just chill.
**** :constructor, :method, :function
     Emit <subroutineBody>, token
**** :while, :if
     Emit token, <statements>
*** :close-brace
**** :class
     Emit token, </class>
**** :constructor, :method, :function
     Emit token, </subroutineBody>, </subroutineDec>
**** :while
     Emit </statements>, token, </whileStatement>
**** :if
     Emit </statements>, token, </ifStatement>
*** :semicolon
**** :field
     Emit token, </classVarDec>
**** :let
     Emit token, </letStatement>
** TODO Notes for compile-keyword
   Something equivalent to the above -- what to do when encountering
   keywords in various contexts
** Expressions are hard
   Mostly basing this on the fact that they're handled separately from
   other structures.
